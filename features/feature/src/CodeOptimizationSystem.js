/*
Sallie Persona Module: CodeOptimizationSystem
Implements advanced code optimization capabilities to improve performance, readability, and maintainability of code generated by Sallie.
Follows Sallie architecture, modularity, and privacy rules.
*/

class CodeOptimizationSystem {
    constructor() {
        this.profiles = new Map();
        this.optimizationResults = new Map();
        this.initializeDefaultProfiles();
    }

    initializeDefaultProfiles() {
        const defaultProfiles = [
            {
                id: 'performance-first',
                name: 'Performance First',
                description: 'Optimize primarily for execution speed, sacrificing some readability if needed',
                focusAreas: ['performance'],
                settings: {
                    aggressiveness: 8,
                    preserveComments: false,
                    preserveFunctionSignatures: true,
                    inlineSmallFunctions: true,
                    extractCommonPatterns: true,
                    optimizeLoops: true,
                    optimizeDataStructures: true,
                    minimizeVariableScope: true
                }
            },
            {
                id: 'balanced',
                name: 'Balanced Optimization',
                description: 'Balance between performance and maintainability',
                focusAreas: ['performance', 'readability', 'maintainability'],
                settings: {
                    aggressiveness: 5,
                    preserveComments: true,
                    preserveFunctionSignatures: true,
                    inlineSmallFunctions: false,
                    extractCommonPatterns: true,
                    optimizeLoops: true,
                    optimizeDataStructures: true,
                    minimizeVariableScope: true
                }
            },
            {
                id: 'readability-first',
                name: 'Readability First',
                description: 'Optimize for code clarity and maintainability',
                focusAreas: ['readability', 'maintainability'],
                settings: {
                    aggressiveness: 3,
                    preserveComments: true,
                    preserveFunctionSignatures: true,
                    inlineSmallFunctions: false,
                    extractCommonPatterns: true,
                    optimizeLoops: false,
                    optimizeDataStructures: false,
                    minimizeVariableScope: false
                }
            },
            {
                id: 'memory-efficient',
                name: 'Memory Efficient',
                description: 'Optimize for minimal memory usage',
                focusAreas: ['memory'],
                settings: {
                    aggressiveness: 7,
                    preserveComments: false,
                    preserveFunctionSignatures: true,
                    inlineSmallFunctions: false,
                    extractCommonPatterns: true,
                    optimizeLoops: true,
                    optimizeDataStructures: true,
                    minimizeVariableScope: true
                }
            }
        ];
        for (const profile of defaultProfiles) {
            this.profiles.set(profile.id, profile);
        }
    }

    createOptimizationProfile(name, description, focusAreas, settings, targetRuntime) {
        const id = `profile_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const defaultSettings = this.profiles.get('balanced').settings;
        const profile = {
            id,
            name,
            description,
            focusAreas,
            targetRuntime,
            settings: {
                ...defaultSettings,
                ...settings
            }
        };
        this.profiles.set(id, profile);
        return profile;
    }

    getOptimizationProfiles() {
        return Array.from(this.profiles.values());
    }

    getProfile(profileId) {
        return this.profiles.get(profileId);
    }

    optimizeCode(code, language, profileId = 'balanced', fileId = `file_${Date.now()}`) {
        const profile = this.profiles.get(profileId) || this.profiles.get('balanced');
        const originalSize = code.length;
        const changes = [];
        let optimizedCode = code;
        switch (language.toLowerCase()) {
            case 'javascript':
            case 'typescript':
                optimizedCode = this.optimizeJavaScript(optimizedCode, profile, changes);
                break;
            case 'python':
                optimizedCode = this.optimizePython(optimizedCode, profile, changes);
                break;
            default:
                optimizedCode = this.applyGenericOptimizations(optimizedCode, profile, changes);
        }
        const optimizedSize = optimizedCode.length;
        const improvementPercent = Math.round((1 - optimizedSize / originalSize) * 100 * 10) / 10;
        const executionTimeImprovement = this.estimateExecutionTimeImprovement(changes);
        const memoryUsageImprovement = this.estimateMemoryImprovement(changes);
        const complexityReduction = this.estimateComplexityReduction(changes);
        const readabilityImprovement = this.estimateReadabilityImprovement(changes, profile);
        const result = {
            fileId,
            originalSize,
            optimizedSize,
            improvementPercent,
            optimizedCode,
            changesLog: changes,
            metrics: {
                executionTimeImprovement,
                memoryUsageImprovement,
                complexityReduction,
                readabilityImprovement
            }
        };
        if (!this.optimizationResults.has(fileId)) {
            this.optimizationResults.set(fileId, []);
        }
        this.optimizationResults.get(fileId).push(result);
        return result;
    }

    optimizeJavaScript(code, profile, changes) {
        let optimizedCode = code;
        const { settings } = profile;
        if (settings.optimizeLoops) {
            optimizedCode = this.optimizeJavaScriptLoops(optimizedCode, changes);
        }
        if (settings.optimizeDataStructures) {
            optimizedCode = this.optimizeJavaScriptDataStructures(optimizedCode, changes);
        }
        if (settings.inlineSmallFunctions) {
            optimizedCode = this.inlineSmallFunctions(optimizedCode, 'javascript', changes);
        }
        if (settings.extractCommonPatterns) {
            optimizedCode = this.extractCommonPatterns(optimizedCode, changes);
        }
        if (settings.minimizeVariableScope) {
            optimizedCode = this.minimizeJavaScriptVariableScope(optimizedCode, changes);
        }
        if (!settings.preserveComments) {
            const withoutComments = optimizedCode.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//gm, '');
            if (withoutComments !== optimizedCode) {
                changes.push({
                    type: 'refactor',
                    description: 'Removed comments to reduce code size',
                    lineStart: 1,
                    lineEnd: optimizedCode.split('\n').length,
                    impact: 'low'
                });
                optimizedCode = withoutComments;
            }
        }
        return optimizedCode;
    }

    optimizeJavaScriptLoops(code, changes) {
        let optimizedCode = code;
        const forInRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s+in\s+(\w+)\s*\)\s*\{/g;
        let match;
        while ((match = forInRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const iterVar = match[1];
            const collection = match[2];
            const arrayPattern = new RegExp(`${collection}\\[${iterVar}\\]`, 'g');
            if (code.match(arrayPattern)) {
                const newLoop = `for (const ${iterVar} of ${collection}) {`;
                const lineStart = code.substring(0, match.index).split('\n').length;
                const lineEnd = lineStart + 1;
                changes.push({
                    type: 'refactor',
                    description: `Converted for...in loop to for...of loop for better performance with array "${collection}"`,
                    lineStart,
                    lineEnd,
                    impact: 'medium'
                });
                optimizedCode = optimizedCode.replace(fullMatch, newLoop);
            }
        }
        const forLoopRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s*=\s*0\s*;\s*\1\s*<\s*(\w+)\.length\s*;\s*\1\+\+\s*\)\s*\{/g;
        while ((match = forLoopRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const iterVar = match[1];
            const array = match[2];
            const newLoop = `${array}.forEach((item, ${iterVar}) => {`;
            const lineStart = code.substring(0, match.index).split('\n').length;
            const lineEnd = lineStart + 1;
            changes.push({
                type: 'refactor',
                description: `Converted classic for loop to forEach for cleaner code with array "${array}"`,
                lineStart,
                lineEnd,
                impact: 'low'
            });
            optimizedCode = optimizedCode.replace(fullMatch, newLoop);
        }
        return optimizedCode;
    }

    optimizeJavaScriptDataStructures(code, changes) {
        let optimizedCode = code;
        const indexOfRegex = /(\w+)\.indexOf\(([^)]+)\)\s*!==?\s*-1/g;
        let match;
        while ((match = indexOfRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const array = match[1];
            const searchTerm = match[2];
            const newCheck = `${array}.includes(${searchTerm})`;
            const lineStart = code.substring(0, match.index).split('\n').length;
            const lineEnd = lineStart;
            changes.push({
                type: 'refactor',
                description: `Replaced indexOf check with includes() for more readable code`,
                lineStart,
                lineEnd,
                impact: 'low'
            });
            optimizedCode = optimizedCode.replace(fullMatch, newCheck);
        }
        const repeatedAccessRegex = /const\s+(\w+)\s*=\s*(\w+)\.(\w+);\s*const\s+(\w+)\s*=\s*\2\.(\w+);/g;
        while ((match = repeatedAccessRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const var1 = match[1];
            const object = match[2];
            const prop1 = match[3];
            const var2 = match[4];
            const prop2 = match[5];
            if (var1 === prop1 && var2 === prop2) {
                const newCode = `const { ${prop1}, ${prop2} } = ${object};`;
                const lineStart = code.substring(0, match.index).split('\n').length;
                const lineEnd = lineStart + 1;
                changes.push({
                    type: 'refactor',
                    description: `Used object destructuring for cleaner property access on "${object}"`,
                    lineStart,
                    lineEnd,
                    impact: 'low'
                });
                optimizedCode = optimizedCode.replace(fullMatch, newCode);
            }
        }
        return optimizedCode;
    }

    minimizeJavaScriptVariableScope(code, changes) {
        let optimizedCode = code;
        const varRegex = /var\s+(\w+)\s*=\s*([^;]+);/g;
        let match;
        while ((match = varRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const varName = match[1];
            const varValue = match[2];
            const reassignmentRegex = new RegExp(`${varName}\s*=`, 'g');
            const reassignmentMatches = code.match(reassignmentRegex) || [];
            const newKeyword = reassignmentMatches.length <= 1 ? 'const' : 'let';
            const newDeclaration = `${newKeyword} ${varName} = ${varValue};`;
            const lineStart = code.substring(0, match.index).split('\n').length;
            const lineEnd = lineStart;
            changes.push({
                type: 'refactor',
                description: `Replaced "var" with "${newKeyword}" for variable "${varName}" to improve variable scoping`,
                lineStart,
                lineEnd,
                impact: 'low'
            });
            optimizedCode = optimizedCode.replace(fullMatch, newDeclaration);
        }
        return optimizedCode;
    }

    optimizePython(code, profile, changes) {
        let optimizedCode = code;
        const { settings } = profile;
        if (settings.optimizeLoops) {
            optimizedCode = this.optimizePythonLoops(optimizedCode, changes);
        }
        if (settings.optimizeDataStructures) {
            optimizedCode = this.optimizePythonDataStructures(optimizedCode, changes);
        }
        if (!settings.preserveComments) {
            const withoutComments = optimizedCode.replace(/#.*$/gm, '').replace(/"""[\s\S]*?"""/gm, '');
            if (withoutComments !== optimizedCode) {
                changes.push({
                    type: 'refactor',
                    description: 'Removed comments to reduce code size',
                    lineStart: 1,
                    lineEnd: optimizedCode.split('\n').length,
                    impact: 'low'
                });
                optimizedCode = withoutComments;
            }
        }
        return optimizedCode;
    }

    optimizePythonLoops(code, changes) {
        let optimizedCode = code;
        const rangeLoopRegex = /for\s+(\w+)\s+in\s+range\(len\((\w+)\)\):/g;
        let match;
        while ((match = rangeLoopRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const iterVar = match[1];
            const collection = match[2];
            const indexingPattern = new RegExp(`${collection}\[${iterVar}\]`, 'g');
            if (code.match(indexingPattern)) {
                const newLoop = `for ${iterVar}_item in ${collection}:`;
                const lineStart = code.substring(0, match.index).split('\n').length;
                const lineEnd = lineStart + 1;
                changes.push({
                    type: 'refactor',
                    description: `Converted range-based loop to direct iteration for better performance with "${collection}"`,
                    lineStart,
                    lineEnd,
                    impact: 'medium'
                });
                optimizedCode = optimizedCode.replace(fullMatch, newLoop);
            } else {
                const newLoop = `for ${iterVar}, item in enumerate(${collection}):`;
                const lineStart = code.substring(0, match.index).split('\n').length;
                const lineEnd = lineStart + 1;
                changes.push({
                    type: 'refactor',
                    description: `Converted range-based loop to enumerate for better performance with "${collection}"`,
                    lineStart,
                    lineEnd,
                    impact: 'medium'
                });
                optimizedCode = optimizedCode.replace(fullMatch, newLoop);
            }
        }
        return optimizedCode;
    }

    optimizePythonDataStructures(code, changes) {
        let optimizedCode = code;
        const appendRegex = /(\w+)\.append\(([^)]+)\)[^\S\n]*\n[^\S\n]*\1\.append\(([^)]+)\)/g;
        let match;
        while ((match = appendRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const listVar = match[1];
            const item1 = match[2];
            const item2 = match[3];
            const newCode = `${listVar}.extend([${item1}, ${item2}])`;
            const lineStart = code.substring(0, match.index).split('\n').length;
            const lineEnd = lineStart + 1;
            changes.push({
                type: 'refactor',
                description: `Replaced multiple append() calls with a single extend() for "${listVar}"`,
                lineStart,
                lineEnd,
                impact: 'low'
            });
            optimizedCode = optimizedCode.replace(fullMatch, newCode);
        }
        const dictUpdateRegex = /(\w+)\s*=\s*\{\}\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)/g;
        while ((match = dictUpdateRegex.exec(code)) !== null) {
            const fullMatch = match[0];
            const dictVar = match[1];
            const key1 = match[2];
            const value1 = match[3];
            const key2 = match[4];
            const value2 = match[5];
            const newCode = `${dictVar} = {${key1}: ${value1}, ${key2}: ${value2}}`;
            const lineStart = code.substring(0, match.index).split('\n').length;
            const lineEnd = lineStart + 2;
            changes.push({
                type: 'refactor',
                description: `Replaced sequential dict updates with direct initialization for "${dictVar}"`,
                lineStart,
                lineEnd,
                impact: 'low'
            });
            optimizedCode = optimizedCode.replace(fullMatch, newCode);
        }
        return optimizedCode;
    }

    inlineSmallFunctions(code, language, changes) {
        changes.push({
            type: 'inline',
            description: 'Function inlining analysis would identify small functions for inlining',
            lineStart: 1,
            lineEnd: 1,
            impact: 'medium'
        });
        return code;
    }

    extractCommonPatterns(code, changes) {
        changes.push({
            type: 'extract',
            description: 'Pattern extraction would identify repeated code patterns for refactoring',
            lineStart: 1,
            lineEnd: 1,
            impact: 'medium'
        });
        return code;
    }

    applyGenericOptimizations(code, profile, changes) {
        let optimizedCode = code;
        const { settings } = profile;
        if (settings.aggressiveness > 6) {
            const withoutExtraWhitespace = optimizedCode.replace(/[ \t]+/g, ' ').replace(/\n+/g, '\n');
            if (withoutExtraWhitespace !== optimizedCode) {
                changes.push({
                    type: 'refactor',
                    description: 'Removed redundant whitespace',
                    lineStart: 1,
                    lineEnd: optimizedCode.split('\n').length,
                    impact: 'low'
                });
                optimizedCode = withoutExtraWhitespace;
            }
        }
        return optimizedCode;
    }

    estimateExecutionTimeImprovement(changes) {
        let improvement = 0;
        for (const change of changes) {
            switch (change.impact) {
                case 'high': improvement += 5; break;
                case 'medium': improvement += 2; break;
                case 'low': improvement += 0.5; break;
            }
            if (change.type === 'algorithm' || change.description.includes('loop')) {
                improvement += 3;
            }
        }
        return Math.min(Math.max(improvement, 0), 50);
    }

    estimateMemoryImprovement(changes) {
        let improvement = 0;
        for (const change of changes) {
            if (change.description.includes('memory') || change.description.includes('data structure') || change.type === 'dataStructure') {
                switch (change.impact) {
                    case 'high': improvement += 7; break;
                    case 'medium': improvement += 3; break;
                    case 'low': improvement += 1; break;
                }
            }
        }
        return Math.min(Math.max(improvement, 0), 40);
    }

    estimateComplexityReduction(changes) {
        let reduction = 0;
        for (const change of changes) {
            if (change.type === 'refactor' || change.type === 'extract') {
                switch (change.impact) {
                    case 'high': reduction += 8; break;
                    case 'medium': reduction += 4; break;
                    case 'low': reduction += 1; break;
                }
            }
        }
        return Math.min(Math.max(reduction, 0), 30);
    }

    estimateReadabilityImprovement(changes, profile) {
        let improvement = 0;
        const readabilityFocused = profile.focusAreas.includes('readability');
        for (const change of changes) {
            if (change.description.includes('comment') && !profile.settings.preserveComments) {
                improvement -= 2;
            }
            if (change.description.includes('destructuring') || change.description.includes('cleaner') || change.description.includes('readable')) {
                improvement += 1;
            }
            if (change.type === 'inline') {
                improvement -= 1;
            }
            if (change.type === 'extract') {
                improvement += 2;
            }
        }
        if (readabilityFocused) {
            improvement = improvement * 1.5;
        }
        return Math.min(Math.max(improvement, -10), 10);
    }

    getOptimizationHistory(fileId) {
        return this.optimizationResults.get(fileId) || [];
    }

    getLatestOptimization(fileId) {
        const history = this.optimizationResults.get(fileId) || [];
        return history.length > 0 ? history[history.length - 1] : undefined;
    }
}

module.exports = CodeOptimizationSystem;
