/*
Sallie Persona Module: CodeOptimizationSystem
Implements advanced code optimization capabilities to improve performance, 
readability, and maintainability of code generated by Sallie.
Follows Sallie architecture, modularity, and privacy rules.
*/

interface OptimizationProfile {
  id: string;
  name: string;
  description: string;
  focusAreas: Array<'performance' | 'memory' | 'readability' | 'maintainability'>;
  targetRuntime?: string;
  settings: {
    aggressiveness: number; // 0-10
    preserveComments: boolean;
    preserveFunctionSignatures: boolean;
    inlineSmallFunctions: boolean;
    extractCommonPatterns: boolean;
    optimizeLoops: boolean;
    optimizeDataStructures: boolean;
    minimizeVariableScope: boolean;
  };
}

interface OptimizationResult {
  fileId: string;
  originalSize: number;
  optimizedSize: number;
  improvementPercent: number;
  optimizedCode: string;
  changesLog: OptimizationChange[];
  metrics: {
    executionTimeImprovement?: number; // percentage
    memoryUsageImprovement?: number;   // percentage
    complexityReduction?: number;      // percentage
    readabilityImprovement?: number;   // -10 to +10 scale
  };
}

interface OptimizationChange {
  type: 'refactor' | 'rewrite' | 'inline' | 'extract' | 'algorithm' | 'dataStructure';
  description: string;
  lineStart: number;
  lineEnd: number;
  impact: 'high' | 'medium' | 'low';
}

export class CodeOptimizationSystem {
  private profiles: Map<string, OptimizationProfile> = new Map();
  private optimizationResults: Map<string, OptimizationResult[]> = new Map();
  
  constructor() {
    // Initialize with default optimization profiles
    this.initializeDefaultProfiles();
  }
  
  /**
   * Initialize default optimization profiles
   */
  private initializeDefaultProfiles(): void {
    const defaultProfiles: OptimizationProfile[] = [
      {
        id: 'performance-first',
        name: 'Performance First',
        description: 'Optimize primarily for execution speed, sacrificing some readability if needed',
        focusAreas: ['performance'],
        settings: {
          aggressiveness: 8,
          preserveComments: false,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: true,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      },
      {
        id: 'balanced',
        name: 'Balanced Optimization',
        description: 'Balance between performance and maintainability',
        focusAreas: ['performance', 'readability', 'maintainability'],
        settings: {
          aggressiveness: 5,
          preserveComments: true,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      },
      {
        id: 'readability-first',
        name: 'Readability First',
        description: 'Optimize for code clarity and maintainability',
        focusAreas: ['readability', 'maintainability'],
        settings: {
          aggressiveness: 3,
          preserveComments: true,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: false,
          optimizeDataStructures: false,
          minimizeVariableScope: false
        }
      },
      {
        id: 'memory-efficient',
        name: 'Memory Efficient',
        description: 'Optimize for minimal memory usage',
        focusAreas: ['memory'],
        settings: {
          aggressiveness: 7,
          preserveComments: false,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      }
    ];
    
    for (const profile of defaultProfiles) {
      this.profiles.set(profile.id, profile);
    }
  }
  
  /**
   * Create a custom optimization profile
   */
  createOptimizationProfile(
    name: string,
    description: string,
    focusAreas: Array<'performance' | 'memory' | 'readability' | 'maintainability'>,
    settings: Partial<OptimizationProfile['settings']>,
    targetRuntime?: string
  ): OptimizationProfile {
    // Generate ID
    const id = `profile_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    
    // Apply default settings for any missing ones
    const defaultSettings = this.profiles.get('balanced')!.settings;
    
    const profile: OptimizationProfile = {
      id,
      name,
      description,
      focusAreas,
      targetRuntime,
      settings: {
        ...defaultSettings,
        ...settings
      }
    };
    
    this.profiles.set(id, profile);
    return profile;
  }
  
  /**
   * Get all available optimization profiles
   */
  getOptimizationProfiles(): OptimizationProfile[] {
    return Array.from(this.profiles.values());
  }
  
  /**
   * Get a specific profile by ID
   */
  getProfile(profileId: string): OptimizationProfile | undefined {
    return this.profiles.get(profileId);
  }
  
  /**
   * Optimize code using a specified profile
   */
  optimizeCode(
    code: string,
    language: string,
    profileId: string = 'balanced',
    fileId: string = `file_${Date.now()}`
  ): OptimizationResult {
    const profile = this.profiles.get(profileId) || this.profiles.get('balanced')!;
    const originalSize = code.length;
    
    // Track optimization changes
    const changes: OptimizationChange[] = [];
    
    // Apply optimizations based on language and profile settings
    let optimizedCode = code;
    
    // Apply different optimization strategies based on language
    switch (language.toLowerCase()) {
      case 'javascript':
      case 'typescript':
        optimizedCode = this.optimizeJavaScript(optimizedCode, profile, changes);
        // Apply advanced optimizations for JS/TS
        optimizedCode = this.applyAdvancedOptimizations(optimizedCode, language, changes);
        break;
        
      case 'python':
        optimizedCode = this.optimizePython(optimizedCode, profile, changes);
        // Apply advanced optimizations for Python
        optimizedCode = this.applyAdvancedOptimizations(optimizedCode, language, changes);
        break;
        
      default:
        // Generic optimizations for other languages
        optimizedCode = this.applyGenericOptimizations(optimizedCode, profile, changes);
    }
    
    // Calculate metrics
    const optimizedSize = optimizedCode.length;
    const improvementPercent = Math.round((1 - optimizedSize / originalSize) * 100 * 10) / 10;
    
    // Estimate other improvements based on changes
    const executionTimeImprovement = this.estimateExecutionTimeImprovement(changes);
    const memoryUsageImprovement = this.estimateMemoryImprovement(changes);
    const complexityReduction = this.estimateComplexityReduction(changes);
    const readabilityImprovement = this.estimateReadabilityImprovement(changes, profile);
    
    // Create result
    const result: OptimizationResult = {
      fileId,
      originalSize,
      optimizedSize,
      improvementPercent,
      optimizedCode,
      changesLog: changes,
      metrics: {
        executionTimeImprovement,
        memoryUsageImprovement,
        complexityReduction,
        readabilityImprovement
      }
    };
    
    // Store the result
    if (!this.optimizationResults.has(fileId)) {
      this.optimizationResults.set(fileId, []);
    }
    this.optimizationResults.get(fileId)!.push(result);
    
    return result;
  }
  
  /**
   * Apply JavaScript/TypeScript optimizations
   */
  private optimizeJavaScript(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Extract code lines for processing
    const lines = optimizedCode.split('\n');
    
    // 1. Optimize loops if enabled
    if (settings.optimizeLoops) {
      optimizedCode = this.optimizeJavaScriptLoops(optimizedCode, changes);
    }
    
    // 2. Optimize data structures if enabled
    if (settings.optimizeDataStructures) {
      optimizedCode = this.optimizeJavaScriptDataStructures(optimizedCode, changes);
    }
    
    // 3. Inline small functions if enabled
    if (settings.inlineSmallFunctions) {
      optimizedCode = this.inlineSmallFunctions(optimizedCode, 'javascript', changes);
    }
    
    // 4. Extract common patterns if enabled
    if (settings.extractCommonPatterns) {
      optimizedCode = this.extractCommonPatterns(optimizedCode, changes);
    }
    
    // 5. Minimize variable scope if enabled
    if (settings.minimizeVariableScope) {
      optimizedCode = this.minimizeJavaScriptVariableScope(optimizedCode, changes);
    }
    
    // For demonstration purposes, we'll return a simple optimization
    // (in a real implementation, the above methods would perform more sophisticated transformations)
    if (!settings.preserveComments) {
      // Remove comments (simplified example)
      const withoutComments = optimizedCode.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//gm, '');
      
      if (withoutComments !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed comments to reduce code size',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutComments;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize JavaScript/TypeScript loops
   */
  private optimizeJavaScriptLoops(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find for...in loops that could be optimized to for...of or forEach
    const forInRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s+in\s+(\w+)\s*\)\s*\{/g;
    let match;
    
    while ((match = forInRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const collection = match[2];
      
      // Look for array usage pattern
      const arrayPattern = new RegExp(`${collection}\\[${iterVar}\\]`, 'g');
      
      if (code.match(arrayPattern)) {
        // This is likely using for...in on an array, which is not optimal
        const newLoop = `for (const ${iterVar} of ${collection}) {`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted for...in loop to for...of loop for better performance with array "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      }
    }
    
    // Optimize array iterations (simplified example)
    // Replace traditional for loops with forEach where appropriate
    const forLoopRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s*=\s*0\s*;\s*\1\s*<\s*(\w+)\.length\s*;\s*\1\+\+\s*\)\s*\{/g;
    
    while ((match = forLoopRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const array = match[2];
      
      // This is a classic for loop over array indices
      const newLoop = `${array}.forEach((item, ${iterVar}) => {`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 1;
      
      changes.push({
        type: 'refactor',
        description: `Converted classic for loop to forEach for cleaner code with array "${array}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      
      // Note: This is a simplified example and would require additional processing
      // to properly handle loop body, closures, and loop endings
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize JavaScript/TypeScript data structures
   */
  private optimizeJavaScriptDataStructures(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace array.indexOf(x) !== -1 with array.includes(x)
    const indexOfRegex = /(\w+)\.indexOf\(([^)]+)\)\s*!==?\s*-1/g;
    let match;
    
    while ((match = indexOfRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const array = match[1];
      const searchTerm = match[2];
      
      const newCheck = `${array}.includes(${searchTerm})`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart;
      
      changes.push({
        type: 'refactor',
        description: `Replaced indexOf check with includes() for more readable code`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCheck);
    }
    
    // Replace object property access patterns with destructuring
    const repeatedAccessRegex = /const\s+(\w+)\s*=\s*(\w+)\.(\w+);\s*const\s+(\w+)\s*=\s*\2\.(\w+);/g;
    
    while ((match = repeatedAccessRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const var1 = match[1];
      const object = match[2];
      const prop1 = match[3];
      const var2 = match[4];
      const prop2 = match[5];
      
      // Only replace if the variables match properties
      if (var1 === prop1 && var2 === prop2) {
        const newCode = `const { ${prop1}, ${prop2} } = ${object};`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Used object destructuring for cleaner property access on "${object}"`,
          lineStart,
          lineEnd,
          impact: 'low'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newCode);
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Minimize JavaScript variable scope
   */
  private minimizeJavaScriptVariableScope(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace var with let/const where possible
    const varRegex = /var\s+(\w+)\s*=\s*([^;]+);/g;
    let match;
    
    while ((match = varRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const varName = match[1];
      const varValue = match[2];
      
      // Check if the value is reassigned later
      // This is a simplified check - in reality, scope analysis would be needed
      const reassignmentRegex = new RegExp(`${varName}\\s*=`, 'g');
      const reassignmentMatches = code.match(reassignmentRegex) || [];
      
      // If there's only one match (the initial assignment), use const, otherwise use let
      const newKeyword = reassignmentMatches.length <= 1 ? 'const' : 'let';
      const newDeclaration = `${newKeyword} ${varName} = ${varValue};`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart;
      
      changes.push({
        type: 'refactor',
        description: `Replaced "var" with "${newKeyword}" for variable "${varName}" to improve variable scoping`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newDeclaration);
    }
    
    return optimizedCode;
  }
  
  /**
   * Apply Python optimizations
   */
  private optimizePython(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Apply Python-specific optimizations
    if (settings.optimizeLoops) {
      optimizedCode = this.optimizePythonLoops(optimizedCode, changes);
    }
    
    if (settings.optimizeDataStructures) {
      optimizedCode = this.optimizePythonDataStructures(optimizedCode, changes);
    }
    
    if (!settings.preserveComments) {
      // Remove comments (simplified)
      const withoutComments = optimizedCode.replace(/#.*$/gm, '').replace(/"""[\s\S]*?"""/gm, '');
      
      if (withoutComments !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed comments to reduce code size',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutComments;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize Python loops
   */
  private optimizePythonLoops(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Convert range-based indexing to direct iteration
    const rangeLoopRegex = /for\s+(\w+)\s+in\s+range\(len\((\w+)\)\):/g;
    let match;
    
    while ((match = rangeLoopRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const collection = match[2];
      
      // Check if this loop uses the index to access the list
      const indexingPattern = new RegExp(`${collection}\\[${iterVar}\\]`, 'g');
      
      if (code.match(indexingPattern)) {
        // This is likely using range(len()) for indexing
        const newLoop = `for ${iterVar}_item in ${collection}:`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted range-based loop to direct iteration for better performance with "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        // This simple replacement would need additional logic to handle
        // the references inside the loop body in a real implementation
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      } else {
        // If index is needed, convert to enumeration
        const newLoop = `for ${iterVar}, item in enumerate(${collection}):`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted range-based loop to enumerate for better performance with "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize Python data structures
   */
  private optimizePythonDataStructures(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace multiple list.append() calls with list comprehensions or extends
    const appendRegex = /(\w+)\.append\(([^)]+)\)[^\S\n]*\n[^\S\n]*\1\.append\(([^)]+)\)/g;
    
    let match;
    while ((match = appendRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const listVar = match[1];
      const item1 = match[2];
      const item2 = match[3];
      
      const newCode = `${listVar}.extend([${item1}, ${item2}])`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 1;
      
      changes.push({
        type: 'refactor',
        description: `Replaced multiple append() calls with a single extend() for "${listVar}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCode);
    }
    
    // Replace dict creation + updates with dict comprehension or initial values
    const dictUpdateRegex = /(\w+)\s*=\s*\{\}\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)/g;
    
    while ((match = dictUpdateRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const dictVar = match[1];
      const key1 = match[2];
      const value1 = match[3];
      const key2 = match[4];
      const value2 = match[5];
      
      const newCode = `${dictVar} = {${key1}: ${value1}, ${key2}: ${value2}}`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 2;
      
      changes.push({
        type: 'refactor',
        description: `Replaced sequential dict updates with direct initialization for "${dictVar}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCode);
    }
    
    return optimizedCode;
  }
  
  /**
   * Inline small functions when appropriate
   */
  private inlineSmallFunctions(
    code: string,
    language: string,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;

    // Analyze functions for inlining opportunities
    const functions = this.analyzeFunctionsForInlining(code, language);

    for (const func of functions) {
      if (this.shouldInlineFunction(func)) {
        // Find all calls to this function
        const callPattern = new RegExp(`\\b${func.name}\\s*\\(([^)]*)\\)`, 'g');
        const calls = [];
        let match;

        while ((match = callPattern.exec(code)) !== null) {
          calls.push({
            fullMatch: match[0],
            args: match[1],
            index: match.index
          });
        }

        // Inline each call
        for (const call of calls) {
          const inlinedCode = this.generateInlinedFunction(func, call.args);
          optimizedCode = optimizedCode.replace(call.fullMatch, inlinedCode);

          changes.push({
            type: 'inline',
            description: `Inlined function ${func.name} (${func.lines} lines)`,
            lineStart: this.getLineNumber(code, call.index),
            lineEnd: this.getLineNumber(code, call.index),
            impact: func.lines <= 3 ? 'low' : 'medium'
          });
        }

        // Remove the original function definition if all calls were inlined
        if (calls.length > 0) {
          const funcPattern = new RegExp(`function\\s+${func.name}\\s*\\([^}]*\\}\\s*`, 's');
          optimizedCode = optimizedCode.replace(funcPattern, '');
        }
      }
    }

    return optimizedCode;
  }

  private analyzeFunctionsForInlining(code: string, language: string): Array<{
    name: string;
    body: string;
    lines: number;
    params: string[];
    complexity: number;
  }> {
    const functions = [];

    if (language === 'javascript' || language === 'typescript') {
      // Match function declarations
      const funcPattern = /function\s+(\w+)\s*\(([^)]*)\)\s*\{([^}]*)\}/g;
      let match;

      while ((match = funcPattern.exec(code)) !== null) {
        const [, name, params, body] = match;
        const lines = body.split('\n').length;
        const complexity = this.calculateFunctionComplexity(body);

        functions.push({
          name,
          body,
          lines,
          params: params.split(',').map(p => p.trim()).filter(p => p),
          complexity
        });
      }

      // Match arrow functions assigned to variables
      const arrowFuncPattern = /const\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>\s*\{([^}]*)\}/g;

      while ((match = arrowFuncPattern.exec(code)) !== null) {
        const [, name, params, body] = match;
        const lines = body.split('\n').length;
        const complexity = this.calculateFunctionComplexity(body);

        functions.push({
          name,
          body,
          lines,
          params: params.split(',').map(p => p.trim()).filter(p => p),
          complexity
        });
      }
    }

    return functions;
  }

  private shouldInlineFunction(func: { lines: number; complexity: number; name: string }): boolean {
    // Inline criteria:
    // - Function is small (3 lines or less)
    // - Low complexity
    // - Not a recursive function (simplified check)
    return func.lines <= 3 && func.complexity < 5 && !func.name.includes('recursive');
  }

  private generateInlinedFunction(func: { body: string; params: string[] }, args: string): string {
    let inlinedBody = func.body;

    // Replace parameters with actual arguments
    const argList = args.split(',').map(arg => arg.trim());
    func.params.forEach((param, index) => {
      if (argList[index]) {
        // Simple parameter replacement - in a real implementation, this would handle scope properly
        const paramPattern = new RegExp(`\\b${param}\\b`, 'g');
        inlinedBody = inlinedBody.replace(paramPattern, argList[index]);
      }
    });

    // Remove return statement and just keep the expression
    inlinedBody = inlinedBody.replace(/^\s*return\s+/, '').replace(/;\s*$/, '');

    return `(${inlinedBody})`;
  }

  private calculateFunctionComplexity(body: string): number {
    // Simple complexity calculation based on control structures
    const complexityIndicators = [
      /if\s*\(/g,
      /else/g,
      /for\s*\(/g,
      /while\s*\(/g,
      /switch\s*\(/g,
      /case\s+/g,
      /\?\s*.*\s*:/g, // ternary operator
      /&&/g,
      /\|\|/g
    ];

    let complexity = 1; // base complexity

    complexityIndicators.forEach(pattern => {
      const matches = body.match(pattern);
      if (matches) {
        complexity += matches.length;
      }
    });

    return complexity;
  }

  private getLineNumber(code: string, index: number): number {
    const lines = code.substring(0, index).split('\n');
    return lines.length;
  }
  
  /**
   * Extract common code patterns into shared functions
   */
  private extractCommonPatterns(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find repeated function calls that could be cached
    const functionCallPattern = /(\w+)\(([^)]*)\)/g;
    const functionCalls = new Map();
    let match;
    
    while ((match = functionCallPattern.exec(code)) !== null) {
      const funcName = match[1];
      const args = match[2];
      const callSignature = `${funcName}(${args})`;
      
      if (!functionCalls.has(callSignature)) {
        functionCalls.set(callSignature, 0);
      }
      functionCalls.set(callSignature, functionCalls.get(callSignature) + 1);
    }
    
    // Report on cacheable function calls
    for (const [signature, count] of functionCalls.entries()) {
      if (count > 3) {
        changes.push({
          type: 'extract',
          description: `Function call "${signature}" appears ${count} times and could benefit from result caching`,
          lineStart: 1,
          lineEnd: 1,
          impact: 'medium'
        });
      }
    }
    
    // Find repeated string literals that could be constants
    const stringLiteralPattern = /(['"`])([^'"`]+)\1/g;
    const stringLiterals = new Map();
    
    while ((match = stringLiteralPattern.exec(code)) !== null) {
      const literal = match[0];
      const content = match[2];
      
      // Only consider longer strings
      if (content.length > 10) {
        if (!stringLiterals.has(literal)) {
          stringLiterals.set(literal, 0);
        }
        stringLiterals.set(literal, stringLiterals.get(literal) + 1);
      }
    }
    
    // Report on repeated string literals
    for (const [literal, count] of stringLiterals.entries()) {
      if (count > 2) {
        changes.push({
          type: 'extract',
          description: `String literal ${literal} appears ${count} times and should be extracted to a constant`,
          lineStart: 1,
          lineEnd: 1,
          impact: 'low'
        });
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Apply advanced performance optimizations
   */
  private applyAdvancedOptimizations(
    code: string,
    language: string,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    
    // Async/await optimization for JavaScript/TypeScript
    if (language.toLowerCase().includes('javascript') || language.toLowerCase().includes('typescript')) {
      optimizedCode = this.optimizeAsyncPatterns(optimizedCode, changes);
    }
    
    // Memory optimization patterns
    optimizedCode = this.optimizeMemoryUsage(optimizedCode, changes);
    
    // Performance bottleneck detection
    optimizedCode = this.detectPerformanceBottlenecks(optimizedCode, changes);
    
    return optimizedCode;
  }
  
  /**
   * Optimize async/await patterns
   */
  private optimizeAsyncPatterns(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find sequential awaits that could be parallelized
    const sequentialAwaitPattern = /await\s+(\w+)\([^)]*\);\s*\n\s*await\s+(\w+)\([^)]*\);/g;
    let match;
    
    while ((match = sequentialAwaitPattern.exec(code)) !== null) {
      const fullMatch = match[0];
      const func1 = match[1];
      const func2 = match[2];
      
      // Check if these are independent calls (simplified check)
      if (func1 !== func2) {
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'algorithm',
          description: `Sequential await calls to ${func1} and ${func2} could be parallelized with Promise.all`,
          lineStart,
          lineEnd,
          impact: 'high'
        });
      }
    }
    
    // Find unnecessary async wrappers
    const unnecessaryAsyncPattern = /async\s+function\s+(\w+)\([^)]*\)\s*{\s*return\s+([^;]+);\s*}/g;
    
    while ((match = unnecessaryAsyncPattern.exec(code)) !== null) {
      const functionName = match[1];
      const returnValue = match[2];
      
      // If return value doesn't contain await, async is unnecessary
      if (!returnValue.includes('await')) {
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 2;
        
        changes.push({
          type: 'refactor',
          description: `Function "${functionName}" doesn't need async keyword as it doesn't await anything`,
          lineStart,
          lineEnd,
          impact: 'low'
        });
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize memory usage patterns
   */
  private optimizeMemoryUsage(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find large array operations that could be optimized
    const largeArrayPattern = /new\s+Array\((\d+)\)/g;
    let match;
    
    while ((match = largeArrayPattern.exec(code)) !== null) {
      const size = parseInt(match[1]);
      if (size > 1000) {
        const lineStart = code.substring(0, match.index).split('\n').length;
        
        changes.push({
          type: 'algorithm',
          description: `Large array allocation (${size} elements) could benefit from lazy initialization or streaming`,
          lineStart,
          lineEnd: lineStart,
          impact: 'medium'
        });
      }
    }
    
    // Find potential memory leaks in event listeners
    const eventListenerPattern = /addEventListener\s*\(\s*['"`](\w+)['"`]\s*,\s*([^)]+)\)/g;
    
    while ((match = eventListenerPattern.exec(code)) !== null) {
      const eventType = match[1];
      const handler = match[2];
      
      // Check if there's a corresponding removeEventListener
      const removePattern = new RegExp(`removeEventListener\\s*\\(\\s*['"\`]${eventType}['"\`]\\s*,\\s*${handler.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\)`);
      
      if (!removePattern.test(code)) {
        const lineStart = code.substring(0, match.index).split('\n').length;
        
        changes.push({
          type: 'refactor',
          description: `Event listener for "${eventType}" should have corresponding removeEventListener to prevent memory leaks`,
          lineStart,
          lineEnd: lineStart,
          impact: 'medium'
        });
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Detect performance bottlenecks
   */
  private detectPerformanceBottlenecks(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find nested loops that could be expensive
    const nestedLoopPattern = /for\s*\([^}]+\)\s*{[^}]*for\s*\([^}]+\)\s*{/g;
    let match;
    
    while ((match = nestedLoopPattern.exec(code)) !== null) {
      const lineStart = code.substring(0, match.index).split('\n').length;
      
      changes.push({
        type: 'algorithm',
        description: 'Nested loops detected - consider algorithm optimization or caching to reduce time complexity',
        lineStart,
        lineEnd: lineStart + 2,
        impact: 'high'
      });
    }
    
    // Find DOM queries that could be cached
    const domQueryPattern = /(document\.querySelector|document\.getElementById|document\.getElementsBy\w+)\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
    const domQueries = new Map();
    
    while ((match = domQueryPattern.exec(code)) !== null) {
      const query = match[2];
      if (!domQueries.has(query)) {
        domQueries.set(query, 0);
      }
      domQueries.set(query, domQueries.get(query) + 1);
    }
    
    for (const [query, count] of domQueries.entries()) {
      if (count > 3) {
        changes.push({
          type: 'refactor',
          description: `DOM query for "${query}" appears ${count} times and should be cached for better performance`,
          lineStart: 1,
          lineEnd: 1,
          impact: 'medium'
        });
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Apply generic optimizations that work for most languages
   */
  private applyGenericOptimizations(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Remove redundant whitespace if aggressive optimization
    if (settings.aggressiveness > 6) {
      const withoutExtraWhitespace = optimizedCode.replace(/[ \t]+/g, ' ').replace(/\n+/g, '\n');
      
      if (withoutExtraWhitespace !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed redundant whitespace',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutExtraWhitespace;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Estimate execution time improvement based on changes
   */
  private estimateExecutionTimeImprovement(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate execution time improvement
    let improvement = 0;
    
    for (const change of changes) {
      switch (change.impact) {
        case 'high':
          improvement += 5;
          break;
        case 'medium':
          improvement += 2;
          break;
        case 'low':
          improvement += 0.5;
          break;
      }
      
      // Additional points for algorithm and loop optimizations
      if (change.type === 'algorithm' || change.description.includes('loop')) {
        improvement += 3;
      }
    }
    
    // Cap the improvement at reasonable values
    return Math.min(Math.max(improvement, 0), 50);
  }
  
  /**
   * Estimate memory usage improvement based on changes
   */
  private estimateMemoryImprovement(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate memory usage improvement
    let improvement = 0;
    
    for (const change of changes) {
      if (change.description.includes('memory') || 
          change.description.includes('data structure') || 
          change.type === 'dataStructure') {
        switch (change.impact) {
          case 'high':
            improvement += 7;
            break;
          case 'medium':
            improvement += 3;
            break;
          case 'low':
            improvement += 1;
            break;
        }
      }
    }
    
    // Cap the improvement at reasonable values
    return Math.min(Math.max(improvement, 0), 40);
  }
  
  /**
   * Estimate complexity reduction based on changes
   */
  private estimateComplexityReduction(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate complexity reduction
    let reduction = 0;
    
    for (const change of changes) {
      if (change.type === 'refactor' || change.type === 'extract') {
        switch (change.impact) {
          case 'high':
            reduction += 8;
            break;
          case 'medium':
            reduction += 4;
            break;
          case 'low':
            reduction += 1;
            break;
        }
      }
    }
    
    // Cap the reduction at reasonable values
    return Math.min(Math.max(reduction, 0), 30);
  }
  
  /**
   * Estimate readability improvement based on changes and profile
   */
  private estimateReadabilityImprovement(changes: OptimizationChange[], profile: OptimizationProfile): number {
    // Readability can be positive or negative depending on the focus
    let improvement = 0;
    
    // If profile focuses on readability, changes are more likely to improve readability
    const readabilityFocused = profile.focusAreas.includes('readability');
    
    for (const change of changes) {
      if (change.description.includes('comment') && !profile.settings.preserveComments) {
        // Removing comments reduces readability
        improvement -= 2;
      }
      
      if (change.description.includes('destructuring') || 
          change.description.includes('cleaner') || 
          change.description.includes('readable')) {
        // These changes tend to improve readability
        improvement += 1;
      }
      
      // Inlining can reduce readability for larger functions
      if (change.type === 'inline') {
        improvement -= 1;
      }
      
      // Extracting patterns usually improves readability
      if (change.type === 'extract') {
        improvement += 2;
      }
    }
    
    // If profile is readability focused, boost the improvement
    if (readabilityFocused) {
      improvement = improvement * 1.5;
    }
    
    // Cap the improvement within the -10 to +10 scale
    return Math.min(Math.max(improvement, -10), 10);
  }
  
  /**
   * Get optimization history for a file
   */
  getOptimizationHistory(fileId: string): OptimizationResult[] {
    return this.optimizationResults.get(fileId) || [];
  }
  
  /**
   * Get latest optimization for a file
   */
  getLatestOptimization(fileId: string): OptimizationResult | undefined {
    const history = this.optimizationResults.get(fileId) || [];
    return history.length > 0 ? history[history.length - 1] : undefined;
  }
}
